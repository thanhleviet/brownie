\documentclass{article}

\usepackage{natbib}
\usepackage{graphics}
\usepackage{amsmath}
\usepackage{indentfirst}
\usepackage[utf8]{inputenc}
\usepackage[usenames,dvipsnames]{color}
\usepackage[colorlinks=true,urlcolor=blue,linkcolor=red,bookmarks=true]{hyperref}

\DeclareMathOperator{\var}{var}
\DeclareMathOperator{\cov}{cov}

%\VignettePackage{RBrownie}
%\VignetteIndexEntry{RBrownie User's Guide}

\begin{document}

<<meta,include=FALSE,echo=FALSE>>=
options(keep.source = TRUE, width = 60)
meta <- packageDescription("RBrownie")
@

\title{RBrownie User's Guide (Version \Sexpr{meta$Version})}
\author{J. Conrad Stack with credit due to others(1)}
\maketitle

\section{Introducing Brownie}

\verb@RBrownie@ is an R package constructed around the C++ command-line program \href{http://www.brianomeara.info/brownie}{Brownie} (available \href{code.google.com/p/brownie}{here}) which was designed by Brian O'Meara in order to fascilitate the estimation and comparison of rates and means of character evolution over different parts of a phylogeny \citep*{brau}.  More specifically, the original Brownie function was a censored rate test under Brownian motion, which allows the comparison of the rates of evolution (under brownian motion) across two monophyletic sister-clades or between a monophyletic and paraphyletic clade.  This analysis allows you to answer questions about differences in the evolutionary rate of two distinct clades (e.g. large subspecies vs. small subspecies).

As Brownie has grown, more and related analyses have been added.  Now it is also possible to perform "non-censored" ratetests and discrete character reconstructions.  The former allows you to compare the rates (Brownian motion model) or means (Ornstein-Uhlenbeck model) of evolution in different character states that are mapped (or painted) onto the phylogeny.  For example, say you had a tree with binary characters mapped onto it branches indicating whether or not ancestors along that branch were thought to have or not have a certain trait and you also had morphological data for all the taxa present in the tree (the tips).  Using a model-testing approach, Brownie allows to you statistically assess whether or not that binary trait is significantly correlated with the rate of evolution of the morphological characteristic measured (or set of morphological characteristics).  Brownie also performs discrete ancestral state evolution (maximum likelihood approach), which produces branch-annotated trees which can used in these non-censored rate tests.  

\verb@RBrownie@'s aim is to exposes all of Brownies capabilities to R users so that they can be used in conjuction with R's existing phylogenetic toolkit.  It provides users with easy ways to run common Brownie analyses and the flexibility to write more complex analyses if desired.  Below I give a short introduction to Brownie and RBrownie, discusses the main datatypes in RBrownie and how to use them, and then a number of examples of the sort of evolutionary analyses that can be completed in RBrownie, including visualizing and understanding the results.

\subsection{How to run}

Over it's lifetime Brownie has evolved from a MATLAB module into a command-line executable available to anyone with a suitable compiler.  In it's current iteration, Brownie 2.0, is available in \href{http://code.google.com/p/brownie/downloads/list}{executable form} for Macintosh operating systems and as \href{http://code.google.com/p/brownie/downloads/list}{source code} which can be installed onto most other operating systems using gcc and the GSL.  (Of course, we encourage you to check out RBrownie as it automates the install process and supports most Brownie functions!)

\subsection{Input / Output}

The Brownie command-line program is very similar in look, feel, and structure to command-line PAUP*.  It reads NEXUS-formatted files including, like PAUP*, a special, proprietary nexus block (BROWNIE) which holds a list of the commands to be executed by the program itself.  We mention this because \verb@RBrownie@ reads and writes these specialized nexus files and any files which \verb@RBrownie@ outputs are directly executable by the Brownie command-line program.

\subsection{More information}

Brownie has a large number of functions in addition to the rate tests described above that we cannot describe in full here, but are worth looking into at least because they will help you better understand RBrownie's capabilities and will allow you to exploit all the useful functions \verb@RBrownie@) has to offer.  The manual for Brownie can be found \href{http://www.brianomeara.info/brownie/manual}{here}.


\section{Introducing RBrownie}

It was mentioned before that RBrownie is an R wrapper for the Brownie program described briefly above. Using the \verb@Rcpp@ package, RBrownie links R with the exact same Brownie code that is used in the Brownie command line program.  It simply builds brownie as a static library and automates the piping and execution of strings that would normally be entered at the Brownie's command line.  As we will see later, the \texttt{brownie} S4 class, one of RBrownie main classes, has a slot for "commands" which holds these strings.  In addition to providing this more streamlined interface to the Brownie core functions, RBrownie adds plotting and visualization functions which make working with output data much easier. 

In order to process the specially formatted nexus files required by Brownie and manipulate their contents from within R, RBrownie has supplemented R's already rich phylogenetic toolkit with a number of novel data structures and methods.  It literally extends a number of classes and methods from \verb@phylobase@, on which, it could be said, RBrownie is roughly based.  To see what other R packages RBrownie uses, load up the package itself which you'll need to do at some point anyway.

<<LoadIn, eval=false,echo=true>>=
require(RBrownie)
@

Now that we have the package loaded, we can look into how to load and/or manipulate our phylogenetic data in RBrownie.

\subsection{Reading nexus files}

Nexus files can be read into R using a number of packages. \verb@ape@ and \verb@phylobase@ both include the functionality to read in trees and sequence data, while phylobase also reads CHARACTERS (or DATA) blocks.  For more information on the options presented by these too packages, check out their documentation files:

<<HelpNexus, eval=false,echo=true, keep.source=TRUE>>=
?read.nexus 		# ape
?read.nexus.data  	# ape
?readNexus  		# phylobase
@

However, Brownie uses nexus blocks beyond those supported by \verb@ape@ and \verb@phylobase@ and \verb@RBrownie@ extends the methods above to accomadate.  For example, Brownie uses an ASSUMPTIONS block to define subsets of the taxa which can be used in its various rate tests.  It also uses a BROWNIE block to store a list of brownie commands to be run automatically if the file is "executed" within the Brownie environment (this is similar to how PAUP* executes files).  So, RBrownie has it's own functions for reading and writing nexus files with these special blocks, \texttt{readBrownie} and \texttt{writeBrownie}.

To illustrate how they work we'll use the parrot dataset which is included with RBrownie (NOTE: you need to have write access to the directory you are in to run this example).

<<InOutDemo, eval=false,echo=true>>=
data(parrot)  
writeBrownie(parrot,file="parrotdata.nex")
newparrot = readBrownie("parrotdata.nex")
@

The two objects \texttt{parrot} and \texttt{newparrot} should be indentical.  It would also be instructive to open the parrotdata.nex file to see how RBrownie writes ASSUMPTIONS blocks, but this isn't necessary.  You may have also noticed that \texttt{parrot} and \texttt{newparrot} are both of class \texttt{list}.  

<<HelpNexus, eval=false,echo=true>>=
class(parrot)   	# list class
class(parrot[[1]])  # brownie class
@

The list class (a very common class in R) is used when multiple trees are found in a single nexus file.  RBrownie represents them as a list of objects which all are of class \texttt{brownie} - these are discussed in the next section.  The \texttt{readNexus} function in phylobase has the same behavior.

\subsection{Classes in RBrownie}

At it's core RBrownie is built around two major classes, \texttt{phylo4d\_ext} and \texttt{brownie}, which both extend \texttt{phylo4d} from phylobase.  In fact, \texttt{phylo4d\_ext} extends \texttt{phylo4d} and \texttt{brownie} in turn extends \texttt{phylo4d\_ext}.  In non-computer-ese this mean that \texttt{phylo4d\_ext} adds a few new data containers (or "slots" as they are known in the S4 world) to \texttt{brownie} and \texttt{brownie} adds a few new data containers to \texttt{phylo4d\_ext}.  To illustrate this, run the R code below, it shows the new slots that are added to \texttt{phylo4d}.

<<SeeClasses, eval=false,echo=true>>=
require(RBrownie)
phylo4d_slots = names(getSlots("phylo4d"))
phylo4d_ext_slots = names(getSlots("phylo4d_ext"))
brownie_slots = names(getSlots("brownie"))
phylo4d_slots
setdiff(phylo4d_ext_slots,phylo4d_slots)
setdiff(brownie_slots,phylo4d_ext_slots)
@

\subsubsection{phylo4d\_ext class}

This class (as implied by the name) is an extension of the \texttt{phylo4d} class from phylobase.  This base class holds a phylogenetic tree and a \texttt{data.frame} containing data for each node of the tree.  The code below shows how to construct a phylogenetic tree and add junk data to the tips of tree which in practice might represent morphological data for each of the taxa.

<<PlotFigOne,fig=TRUE,echo=TRUE,keep.source=TRUE>>=
require(phylobase)
# generate a random coalescent tree with 10 tips
ape_tree = rcoal(10)

# convert tree from 'phylo' (ape) to 'phylo4' (phylobase) format
phy_tree = as(ape_tree,"phylo4")

# generate junk data for the tips
sample_tipdata = runif(10)

# combine the phylogenetic tree and the sample data
phyd_tree = phylo4d(phy_tree,tip.data=sample_tipdata)
plot(phyd_tree)
@

\texttt{phylo4d\_ext} adds to this class 'subnodes' and tree weights.  Subnodes are internal nodes mapped directly onto an existing branches and are conceptually similar to singleton nodes (but offer a bit more flexibility from a programming standpoint).  The \texttt{phylo4d\_ext} class was created mainly to handle SIMMAP-formatted nexus trees, but instances can be created from scratch as well.

<<PlotFigTwo,fig=TRUE,echo=TRUE,keep.source=TRUE>>=
require(RBrownie)
ape_tree = rcoal(10)
phy_tree = as(ape_tree,"phylo4")
#
### create tip data
#
# create binary data indicators for all nodes (including internal)
sample_binarydata = data.frame(sample(c(0,1),19,replace=TRUE))
names(sample_binarydata) <- "hasTrait"
#
#
### subnodes
sample_subnodedata = data.frame(sample(c(0,1),4,replace=TRUE))
#
# should be the same name as the parent data.frame
names(sample_subnodedata) <- "hasTrait" 
#
# add subnodes to 4 random branches
sample_edges = sample(seq(nrow(edges(phy_tree))),4) 
#
# could positions for the subnodes along their branches 
# (as a fraction of the overall branch length)
sample_positions = runif(4) 

# note that "extra" arguments (all.data) are passed 
# on to the phylo4d constructor
phyext_tree = phyext(phy_tree, 
			snode.data=sample_subnodedata, 
			snode.branch=edges(phy_tree)[sample_edges,], 
			snode.pos=sample_positions,
			all.data=sample_binarydata)

# nodes, subnodes, and branches without the "trait" (state 0) are colored black
# nodes, subnodes, and branches with the "trait" (state 1) are colored red
plot(phyext_tree,states=c(0,1),states.col=c("black","red"))
@

In the plot above, the subnodes are clearly seen as dots on an existing branch.  This is usually used to indicate state changes along a branch, but because of the randomly generated data above you might see an entirely red branch with a red subnode or something similarly odd.  A better example might be seen in the parrot data set.

<<PlotFigThree,fig=TRUE,echo=TRUE>>=
require(RBrownie)
data(parrot)
plot(parrot[[1]])
@

Now the binary state data are represented by the default colors and a state change is clearly visible on the branch from the taxon Sparisoma\_chrysopterum.  In this case, state 0 and state 1 represent a life history trait of parrot fish, namely whether they scrape (0) or excavate (1) coral.  You can clearly see that, in this tree at least, that life history trait changes throughout the evolutionary history of the parrot fish at both internal nodes and along a branch at a subnode.  Brownie uses this state information, as we will see later, to address questions such as "Does coral excavating\/scraping limit morphological evolution in parrotfishes" \citep*{phylo}

Anyhow, to view subnode information these accessor functions are available.

<<PhyextAcc,echo=TRUE,eval=FALSE>>=
snid(phyext_tree)
sndata(phyext_tree)
snposition(phyext_tree)
snbranch(phyext_tree)
showSubNodes(phyext_tree)
@

And to add a new subnode manually, try this

<<PhyextAcc,echo=TRUE,eval=FALSE,keep.source=TRUE>>=
# place the node along the first branch
ancestor.node = edges(phyext_tree)[1,1]
descendant.node = edges(phyext_tree)[1,2]
node.position = 0.5 # half way along the branch
node.data = data.frame(1) # give it state = 1
names(node.data) <- "hasTrait"

phyext_tree = addSubNode(phyext_tree,
				ancestor.node,
				descendant.node,
				node.position,
				node.data)
@

You might notice that the subnode position is represented currently as a two-column matrix.  In a future version, the subnodes will float between two values representing our confidence on where the state change (and thus the subnode) might occur.  \texttt{weight} is another aspect of the \texttt{phylo4d\_ext} class that will be supported better in future versions.  

Finally, subnodes will most be read in from SIMMAP-formatted nexus files and not added manually.  The SIMMAP format was created represent state mappings onto branches (subnodes) in nexus tree files and the standard has gone through a number of iterations.  Currently, only SIMMAP version 1.0 and 1.1 are supported by \verb@RBrownie@ - we are working to add support for others.  \verb@RBrownie@ has functions for reading and / writing in this format with functions similar to \verb@ape@'s \texttt{read.nexus} and \texttt{write.nexus} functions.  (NOTE: you need to have write access to the directory you are in to run this example).

<<InOutDemoTwo, eval=false,echo=true>>=
data(parrot)
write.nexus.simmap(parrot,file="parrottmp.nex")
newparrot = read.nexus.simmap("parrottmp.nex")
@

\subsubsection{brownie class}

Many examples in the last section where the phylo4d\_ext class was explained used the parrot dataset included in RBrownie.  But, the parrot object is a list of \texttt{brownie} objects, right?  Yes, the \texttt{brownie} class extends the phylo4d\_ext class further (adding two new slots).  We can confirm that this is the case:

<<InheritsOne, eval=false, echo=true>>=
data(parrot)
inherits(parrot[[1]],"phylo4d_ext")
@

\texttt{brownie} simply adds a few new slots to \texttt{phylo4d\_ext}.  The two classes were not combined into one larger class as we thought that the extended phylo4d class would hopefully have some use outside of RBrownie and furture development should reflect that. Moving on though, the two new slots are \texttt{commands}, to hold brownie text commands, and \texttt{datatypes}, which adds annotations to the \texttt{data} slot.

First, the \texttt{commands} slot. It's purpose is to hold the text strings that will eventually be executed in Brownie itself.  That is, once the phylogenetic tree and any node data is loaded into the Brownie core, these commands are run.  They describe actions that the brownie core should take: analyses might need to be run on certain trees and not others, choose which models to use when model tests are done, etc.  A full list and description of all the commands can be found in the \href{http://www.brianomeara.info/brownie/manual}{Brownie manual}.  

For all but the most advanced users however, these commands will be filled in automatically by some higher level functions (seen later on) which were designed to make it easy to set up and execute common analysis.  If you do find yourself needing to manipulate these commands, there are a number of accessor functions set up for you to do this

<<BrownieExample,echo=TRUE,eval=TRUE,keep.source=TRUE>>=
require(RBrownie)
data(geospiza_ext)
commands(geospiza_ext)

# Removal
geo_none1 = clearCommands(geospiza_ext) # remove all commands
geo_none2 = removeCommands(geospiza_ext,"discrete") # remove all 'discrete' commands
geo_3 = removeCommands(geospiza_ext,1) # remove the first command

# Addition
geo_add = geospiza_ext
commands(geo_add,add=TRUE) <- "choose t=1"   # add a command to the end of the vector
commands(geo_add,add=TRUE,index=1) <- "choose c=1"  # add a command at a certain index
commands(geo_add,replace=TRUE) <- "choose d=1"  # replace ALL commands with this one
#
geo_add = geospiza_ext
# replace command at a certain index with this one
commands(geo_add,add=TRUE,index=1,replace=TRUE) <- "choose d=1"  
@

Second, the \texttt{datatypes} slot.   \texttt{datatypes} is a character vector which contains a description of each column in the \texttt{data} slot.  RBrownie uses this information in order to write different parts of the \texttt{data} data.frame to different blocks in a nexus file.  For example, discrete and continuous data are treated differently in Brownie and each require their own nexus block (CHARACTERS and CHARACTERS2 are used).  Also, taxa sets are stored in the \texttt{data} slot as binary data (1 is taxon is in the set, 0 if not) and they are written to an ASSUMPTIONS nexus block.  To illustrate this, lets look at the data in parrot data set.  (NOTE: The \texttt{data} slot comes from phylobase, it's accessor functions also come from there.  \texttt{tdata} is an example)

<<BrownieExample,echo=TRUE,eval=TRUE,keep.source=TRUE>>=
require(RBrownie)
data(parrot)
# How many columns are in the data.frame?
ncol(tdata(parrot[[1]]))
# What are their names?
names(tdata(parrot[[1]]))
# What are their types? 
datatypes(parrot[[1]])
@

We can see here that this brownie object contains five columns in it's data.frame and they are of 3 different types.  The first \texttt{discrete}, indicates discrete data; the second and third \texttt{cont} indicate continuous data, and the forth and fifth \texttt{taxset} indicate a special binary data column showing which taxa are in a certain set of taxa.  

There are handy ways to access these datatype strings when using them:
<<BrownieExample,echo=TRUE,eval=FALSE,keep.source=TRUE>>=
discData()
contData()
taxaData()
genericData() # undefined data (shouldn't be used)
brownie.datatypes() # show all
@

Adding new data to a \texttt{brownie} object is almost identical to how it is done in phylobase - the \texttt{addData} function is actually specified for class \texttt{brownie} - with the exception that you can specify which datatype you want to label it as.  For example:

<<BrownieAddData,echo=TRUE,eval=TRUE,keep.source=TRUE>>=

require(RBrownie)
data(parrot)

# junk morphological data for tips
junkcont = runif((nNodes(parrot[[1]])+1),-10,10)

# junk discrete data for tips / nodes
junkdisc = sample(letters[1:4], length(junkcont) + nNodes(parrot[[1]]),replace=TRUE)

parrot_new = addData(parrot, tip.data=junkcont, known.types=contData())
parrot_new = addData(parrot_new, all.data=junkdisc, known.types=discData())

datatypes(parrot_new)
@

Now there are two new datatypes in the parrot data which we specified.  Also note how \texttt{addData} and \texttt{datatypes} can be called on list objects as well as brownie objects - the list variant of these functions actually adds the data to each object in that list.  RBrownie has a number of such convenient functions.

Adding taxa set data is a bit different.  There is an accessor function in \verb@RBrownie@ called \texttt{taxasets} which gives the user access to all the data columns representing sets of taxa.  It can also be used to create new taxasets:

<<BrownieAddTaxa,echo=TRUE,eval=FALSE,keep.source=TRUE>>=
hasTaxasets(parrot) # see if there are any taxasets
taxasets(parrot) # return taxasets as data.frame
#
# use binary data to indicate membership in a taxa set
junktaxaset = sample(c(0,1),nTips(parrot[[1]]),replace=TRUE)
taxasets(parrot,taxnames="Random_set") <- junktaxaset
#
# OR
#
# use taxa names to indicate membership in a taxa set
all_sparisoma = grep("Sparisoma",tipLabels(parrot[[1]]),value=TRUE)
taxasets(parrot,taxnames="sparisomas") <- all_sparisoma
@

And you can plot a taxaset as well

<<BrowniePlotTaxa,echo=TRUE,eval=TRUE,keep.source=TRUE,fig=TRUE>>=
require(RBrownie)
data(parrot)
plot.taxaset(parrot[[3]],2) # plot the second taxaset
@


And that is the \texttt{brownie} class which can be thought of as a specialization of generic phylogentic trees + data.  It would be instructive to take some of the examples above, where data is added to data contained within RBRownie, write it out to a file using \texttt{writeBrownie}, and look at how the different changes manifest in the nexus file itself.  

\section{Running Analyses}

Now that you are familiar with the data structures in RBrownie, we can move on to using their methods effectively.  RBrownie includes a number of high-level functions to perform the most common evolutionary analyses (discussed in the first three subsections), but also exposes a number of lower-level functions making it easier for the user to tweak or customize the commands the will eventually be run on the Brownie core.

RBrownie provides two general ways to run any of these analyses.  First, they can be run directly by calling one of the pre-packaged functions of the form \texttt{runTEST}.  These functions clear away anything currently in the commands block and run the \texttt{TEST} specified.  Alternatively, commands can be added to a \texttt{brownie} objects one by one using functions of the form \texttt{addTEST} or \texttt{addOPTION} and then all the commands in the brownie object can be executed using \texttt{run.asis}.  We'll see examples of all of these below.

\subsection{Censored Rate Test}

Briefly, the purpose of this test is to calculate and compare rate of continuous character evolution in different parts of a tree.  A \href{http://www.brianomeara.info/brownie/manual\#Testingcontinuousratesoriginalcensoredapproach}{detailed description} of this test is beyond the scope of this guide, but can be found in the Brownie manual.

Brownie uses the 'ratetest' command to perform this test allowing the user to specify a number of optional parameters and so function RBrownie provides functions which add this command along with various options to the \texttt{commands} slot of a \texttt{brownie} object.  Let's look at an example:

<<RateTestOne,echo=TRUE,eval=TRUE,keep.source=TRUE>>=
require(RBrownie)
data(parrot)
par.new = clearCommands(parrot) # empty the commands slot
par.new = addCensored(par.new,reps=1000,taxset=taxaset.names(par.new)[2],charloop=TRUE)
commands(par.new)
@

As you can see, the 'ratetest' command has been added to all the \texttt{brownie} objects in the parrot list.  Now that we have added this command, we can run the analysis manually:

<<RateTestTwo,echo=TRUE,eval=FALSE,keep.source=TRUE>>=
# run the brownie objects as is and get the text 
# output from the brownie core
rawtxt = run.asis(par.new)$textout 
rawtxt = scan.textout(rawtxt)  # process text output 
test.results = read.ratetest.output(txt=rawtxt) 
summaryRatetest(test.results)
@

The last command, \texttt{summaryRatetest}, provides a summary of the ratetest results - it's a very handy command, providing a rough interpretation of the data in \texttt{test.results}.  Again, the reader is referred to the brownie manual for a more \href{http://www.brianomeara.info/brownie/manual\#Testingcontinuousratesoriginalcensoredapproach}{detailed description} of the data.frame and it's summary.  But getting back to RBrownie, there is a more straight-forward way to run this test than the manual method used above that adds commands and processes the text output automatically.  Here it is:

<<RateTestThree,echo=TRUE,eval=FALSE,keep.source=FALSE>>=
require(RBrownie)
data(parrot)
test.results = runCensored(parrot,taxset="intrajoint",reps=1000,charloop=T)
summaryRatetest(test.results)
@

\subsubsection{Plots}

In addition to the \texttt{summaryRatetest} function, there is also a specialized plotting function for visualizing which branches of a tree the ratetest command will remove (see the brownie manual for more information on this).  The branches to be removed are shown as dashed, the branches of the taxa in the taxaset 'intrajoint' are shown in red.

<<RateTestFour,echo=TRUE,eval=TRUE,keep.source=TRUE,fig=TRUE>>=
require(RBrownie)
data(parrot)
taxaset.names(parrot) # we want to look at 'intrajoint', so use taxind=2
plot.censored(parrot[[2]],taxind=2)
@


\subsection{Non-Censored Rate Test}

\subsection{Discrete Ancestral State Reconstruction}

\subsection{Custom Tests}

\section{Advanced Plotting}

\section{Future development}

If there is a feature you would like to see supported in either Brownie or RBrownie, please post a feature request to the \href{http://groups.google.com/group/brownie-users}{brownie-users google group}.

\begin{thebibliography}{}

\bibitem[Bodega Phylogenetics Wiki (2010)]{phylo}
Price, S., Wainwright, P. (2010). Testing for different rates of continuous trait evolution using likelihood. (http://bodegaphylo.wikispot.org/Morphological\_Diversification\_and\_Rates\_of\_Evolution)


\bibitem[O'Meara, et al.(2006)]{brau}
O'Meara, B. C., Ane, C., Sanderson, M. J. and Wainwright, P. C. (2006). 
\newblock Testing for different rates of continuous trait evolution using likelihood. 
\newblock In \emph{Evolution}, 60 ,922--933.


\end{thebibliography}



\end{document}
